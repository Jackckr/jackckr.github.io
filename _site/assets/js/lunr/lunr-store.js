var store = [{
        "title": "Go Redis连接池实现",
        "excerpt":"go-redis连接池实现 背景 因为inspector需要正式接入redis的秒级监控，在秒级监控场景下，如果redis driver的使用有任何不当，都有可能导致线上故障，所以特地了解了一下go-redis driver的具体实现：包括连接池实现方式，连接方式，失败重连机制，自动重连机制等。 主要struct结构     图1.1 go-redis主要struct结构在go-redis driver中主要有上面四个struct/interface，而返回给用户使用的就是Client struct了。Client有两个比较重要的成员，一个是baseClient，还有一个是cmdable，其中前者维护了一个连接池对象以及基础执行方法：process——执行单命令，processPipeline——批量执行命令，processTxPipeline——事务批量执行命令，而后者则是一个拥有redis基础命令function的struct。因为采集只会用到单命令模式，所以后面只会讲到这个命令。 主要方法 初始化 go-redis初始化时采用的lazy init的方式，对于当new一个client后，并不会直接创建连接，而只是初始化相关的option属性，并返回一个没有任何连接的client func NewClient(opt *Options) *Client {       opt.init()       c := Client{              baseClient: baseClient{                     opt:      opt,                     connPool: newConnPool(opt),              },       }       c.baseClient.init()       c.init()       return &amp;c}上面的newConnPool，c.baseClient.init和c.init方法都只是初始化需要的相关属性，不会有任何连接的建立。而newConnpool则是创建出对应的对象池队列： func NewConnPool(opt *Options) *ConnPool {       p := &amp;ConnPool{              opt: opt,              queue:     make(chan struct{}, opt.PoolSize),              conns:     make([]*Conn, 0, opt.PoolSize),              freeConns: make([]*Conn, 0, opt.PoolSize),       }       if opt.IdleTimeout &gt; 0 &amp;&amp; opt.IdleCheckFrequency &gt; 0 {              go p.reaper(opt.IdleCheckFrequency)       }       return p}我们可以看到，如果配置的idleTimeout或者idleCheckFrequncy参数，那么就会起一个协程，对空闲连接进行reap。在对于控制连接池大小上，这里使用了queue这个channel，这样就避免了对计数的原子比较和加减，也就避免了锁的使用。 执行操作 在执行操作的时候，Client会调用cmdable对象来执行对应的操作，而cmdable中的process对象则是来源于baseClient中的connpool func (c *cmdable) Ping() *StatusCmd {       cmd := NewStatusCmd(\"ping\")       c.process(cmd)       return cmd}通过这种方法，就将连接池和命令分离开来，这样也将常用的命令都封装在了一起。 如何获取链接 在每次真正执行操作之前，client都会调用connpool的Get方法，在这个Get方法中实现了链接的创建和获取。 select {\tcase p.queue &lt;- struct{}{}:\tdefault:\t\ttimer := timers.Get().(*time.Timer)\t\ttimer.Reset(p.opt.PoolTimeout)\t\tselect {\t\tcase p.queue &lt;- struct{}{}:\t\t\tif !timer.Stop() {\t\t\t\t&lt;-timer.C\t\t\t}\t\t\ttimers.Put(timer)\t\tcase &lt;-timer.C:\t\t\ttimers.Put(timer)\t\t\tatomic.AddUint32(&amp;p.stats.Timeouts, 1)\t\t\treturn nil, false, ErrPoolTimeout\t\t}\t}首先，这里会给connPool初始化时创建的channel发送一个信号，如果信号阻塞了，说明当前已经用满连接池的所有链接，那么此时会在timeout时间内，尝试继续发送信号，如果还是阻塞，则返回错误，否则即刻停止timer，进行后续操作。在这里有一个细节比较好，就是timer对象的对象池化，这样就不用频繁创建然后等gc去回收timer小对象了。不过这种优化必须在连接池被用满的情况下效果比较明显。还有强调一点的就是，这里并不获取任何连接，这里获取的是接下来获取真正连接的“资格”。当拿到获取链接的“资格”后，接下来便是去获取真正的链接 for {       p.freeConnsMu.Lock()       cn := p.popFree()       p.freeConnsMu.Unlock()       if cn == nil {              break       }       if cn.IsStale(p.opt.IdleTimeout) {              p.CloseConn(cn)              continue       }       atomic.AddUint32(&amp;p.stats.Hits, 1)       return cn, false, nil}这里先遍历Client中free conn数组，如果找到没有超过idleTimeout的链接，则返回，遍历期间，如果找到stale的conn，则会直接close掉。这里面其实有个可以优化的地方，因为如果free队列里面的所有conn都是stale的，那么后面会需要重新new，而这里完全可以留下一个当做本次使用（因为这个idleTimeout只是客户端的timeout），然后批量关闭stale的，因为close操作实现加了锁，这样锁使用量会少。 如何创建连接 opt.Dialer = func() (net.Conn, error) {       conn, err := net.DialTimeout(opt.Network, opt.Addr, opt.DialTimeout)       if opt.TLSConfig == nil || err != nil {              return conn, err       }       t := tls.Client(conn, opt.TLSConfig)       return t, t.Handshake()}创建连接，其实也就是创建了一个tcp连接 如何实现失败重连/自动重连 go-redis在每次执行命令失败以后，会判断当前失败类型，如果不是redis server的报错也不是设置网络timeout后的timeout报错，那么则会将该连接从连接池中remove掉，如果有设置重试次数，那么就会继续重试命令，又因为每次执行命令时会从连接池中获取链接，而没有又会新建，这样就变相实现了失败重连/自动重连机制。 if internal.IsBadConn(err, false) {       _ = c.connPool.Remove(cn)       return false}_ = c.connPool.Put(cn)return true通过这种方式，初始化好一个redis client之后，便不用再关注重连逻辑了。 ","categories": ["golang"],
        "tags": [],
        "url": "http://localhost:4000/golang/go-redis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/",
        "teaser":"http://localhost:4000/assets/pic/golang/go-redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"},{
        "title": "Golang map实现",
        "excerpt":"Golang map实现 前言 golang在自己的内置类型中实现了hashmap这种数据结构，而且这个hashmap的key支持任意能计算hash值的数据类型，可以说是十分方便了。因此我在各种项目中都大量使用了这种数据结构，但是越是这种通用型的数据结构，想要在某个特定的场景中用好，却不是一件那么简单的事情，所以为了不给项目埋坑，深入了解hashmap的实现就是一件十分有必要的事情了。 map基本原理 hashmap是一个十分常见也是十分经典的数据结构，而通常一个hashmap需要将key进行hash计算，然后映射到一个数组下标上，然后通过数组下标访问，达到O(1)时间复杂度快速访问，但是无论多美完美的hash算法，都会导致多个key的最后计算结果相同——即hash碰撞。而解决hash碰撞也有多种方法，比如退避法，拉链法等等。其中，拉链法是最为常见也是最为有效的方法，因此golang的hashmap也是采用的拉链法，但是golang在普通的拉链法上又做了许多性能上的优化。 golang hashmap基本概念原理 golang的hashmap是由一个个的桶(bucket)组成，每个桶额定可以放8个元素，通过hash算法定位桶的下标，然后在每个桶中再进行查找，如果某个hash值的元素个数超过8，那么则在桶后面拉链处一个新桶（overflow buckets），用来装新数据。然后除此外，这里还有一个loadFactor的概念，即桶平均的装载率。桶的装载率直接影响了overflow buckets的数目和内存使用率，通过作者测试，当loadFactor在6.5的时候能达到最好的平衡。  数据结构 在上述数据结构中，最为重要的就是bmap这个数据结构了，也就是上文介绍的一个bucket。bmap包含了两部分，第一个部分是tophash这样一个数据结构，这个主要作为在bucket中进行快速定位的一种“filter”，然后再后面就是8个key和8个value的数据空间，这部分数据的访问全部通过地址pointor+下标偏移来完成。然后最后一个就是一个pointor，用来指向overflow的bucket数据。 详细介绍 上面简单介绍了golang hashmap的基本原理，那么下面就通过增删改查操作来详细介绍一下它的一些实现细节，并通过这个来指导我们平时自己的使用 map初始化 map的初始化通过makemap方法实现，该方法会做一些合法性判断，然后如果传入了初始化大小，则会根据大小和loadFactor来创建对应数量的bucket func overLoadFactor(count int64, B uint8) bool {\t// TODO: rewrite to use integer math and comparison?\treturn count &gt;= bucketCnt &amp;&amp; float32(count) &gt;= loadFactor*float32((uintptr(1)&lt;&lt;B))}如果没有传大小，那么只会初始化map的数据结构，而不会创建任何的bucket——lazy init。 ","categories": ["golang"],
        "tags": [],
        "url": "http://localhost:4000/golang/golang-map%E5%AE%9E%E7%8E%B0/",
        "teaser":"http://localhost:4000/assets/pic/golang/go-hmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"},{
        "title": "Jekyll基本概念介绍和安装",
        "excerpt":"  本文旨在简单介绍博客站搭建工具jekyll的基本概念和用法 jekyll是什么？ 对于刚刚接触jekyll这个博客搭建神器的小白——比如我，来说，对于jekyll这个东西应该会感到极其陌生吧。所以这里简要介绍一下jekyll是什么：   Transform your plain text into static websites and blogs. 这个是jekyll官网首页的一句话。博主学习后按照理解翻译过来就是：jekyll是一个基于ruby将纯文本转换成静态网站和博客的一个工具，该工具支持将markdown，liquid，HTML&amp;CSS等转换成静态网站。所以通过上述描述，我们知道，这个工具需要一个环境和支持三种“语言”文本格式，即：ruby 环境+markdown、liquid、HTML&amp;CSS。 ruby   ruby是一种面向对象、命令式、函数式、动态的通用编程语言 以上介绍摘自百度百科。因为博主不是rubyer，所以就不做过多介绍，大家可以通过ruby -v来检查自己电脑是否安装有ruby，如果没有或者版本过低，可以按照官网的介绍进行安装ruby中国官网 markdown markdown是一种纯文本的格式化标记语言，通过打标签等方式，来给纯文本文章加上格式，并可以方便的转换成html等网页格式，默认后缀名为md。所以通过这里，就发现，markdown真的是一个天然用来写博客的语言。具体语法可以自行进行搜索。 liquid liquid是一个面向html的模板语言，可以在html中方便的使用来达到根据不同的数据参数生成不同的html页面的功能。 html&amp;&amp;css 这个就不多做介绍了 jekyll安装 按照jekyll官网的介绍，安装需要执行以下一个命令： gem install bundler jekyll这个命令安装了两个东西，一个是bundler——ruby是用的依赖管理工具，一个就是我们需要的jekyll了。这两个都需要装好才能使用。可是有些mac版本os因为比较新，然后apple官方对于权限的管理变得很严，所以在安装的过程中可能会出现以下两种报错： ERROR:  While executing gem ... (Gem::FilePermissionError)    You don't have write permissions for the /Library/Ruby/Gems/2.3.0 directory.这种错就是很常见的权限问题，所以只需要sudo一下就可以了。除此之外，还可能会有这样的报错: ERROR:  While executing gem ... (Gem::FilePermissionError)    You don't have write permissions for the /usr/bin directory.这个报错是说尽管sudo了，但是依旧还是不能在/usr/bin目录下取的安装所需要的权限，此时的解决方法就是换一个目录，即命令如下 sudo gem install -n /usr/local/bin bundler jekyll这样就可以顺利的安装好jekyll了 jekyll使用 只需要创建自己的博客目录，并执行启动命令就可以了： mkdir conan &amp; cd conanbundle exec jekyll serve然后你会看到类似的日志，此时再浏览器中访问http://127.0.0.1:4000 就可以了 Configuration file: /Users/apple/Workspace/jackckr.github.io/_config.yml            Source: /Users/apple/Workspace/jackckr.github.io       Destination: /Users/apple/Workspace/jackckr.github.io/_site Incremental build: disabled. Enable with --incremental      Generating...      Remote Theme: Using theme mmistakes/minimal-mistakes   GitHub Metadata: No GitHub API authentication could be found. Some fields may be missing or have incorrect data.                    done in 22.817 seconds. Auto-regeneration: enabled for     Server address: http://127.0.0.1:4000  Server running... press ctrl-c to stop.在jekyll启动的时候，就会扫描当前目录下的所有文件，然后根据约定的语法规则生成博客站。因为我们通常使用的时候，都是直接下载第三方写好的模板，然后放入自己的博客就可以了，所以这里不详细介绍这些规则，有兴趣的朋友可以直接去jekyll官网学习。 jekyll基本概念介绍 Front matter 一开始接触这个词汇的时候，博主我表示真是一脸懵逼😲。然后也是测试，看别人的写法，然后才理解这个的含义。下面举例如下： ---layout: postsauthor: conanauthor_profile: true---markdown正文如上面所示，front matter顾名思义，就是在每个markdown文件的开头加上一些“标签”（以“—”符号开头和结尾），来表示这个文档的属性，如上面所说jekyll会扫描所有文件，然后这些标签就会被jekyll所识别，然后就会影响文章html的生成格式。比如上面的layout: posts就表示这篇用posts这个“格式”来展示文章，并且显示的作者是conan。front matter里面的标签，有些事jekyll的保留使用的key(如layout)，有些则是由具体的模板来定义使用的(如author_profile)，所以这些需要查阅具体的模板文档。 layouts jekyll布局模板。在根目录下有一个_layouts目录，然后里面存放的html文件就是布局文件，文件名就是layouts的值，比如如果有posts.html，那么就可以在front matter中指定layout为posts，那么博客就会以posts.html中定义的格式进行展示。这个可以自己写，也可以直接使用第三方的模板。 posts 在根目录下有一个_posts目录，顾名但我思不了义┑(￣Д ￣)┍，这个目录就是存放我们markdown格式博客的地方。在这里，可以有任意数量和深度的文件夹来组织我们的markdown文件，但是markdown文件名却必须有规定的格式：YYYY-MM-DD-title,这里必须是4位数的年-2位数的月-2位数的日-文章名，其中文章名可以有任意字符包括“-”。只有这种格式的文章才会被jekyll识别，否则是不会被用来生成html的。。。。 pages 在根目录下通常还有一个_pages的目录，这个目录下存放的就是一些与博客无关，比如home，about，404等单页面(可以是md或html格式)，这些页面的文件名会直接被用在url，或者通过permalink这样一个front matter去指定。 data files 在根目录下有一个_data的目录，这里主要是存放一些跟导航栏相关的配置信息，所以通常会有一个navigation.html文件，然后你可以根据模板的要求，去配置一些导航栏。 collections 这个主要是将多个同一类型的博客进行统一管理的功能，普通用法基本用不上，有兴趣的朋友可以去官网自己学习使用。 ","categories": ["jekyll"],
        "tags": [],
        "url": "http://localhost:4000/jekyll/jekyll%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/",
        "teaser":null},{
        "title": "利用jekyll+github pages搭建个人博客总结",
        "excerpt":"背景 博主一直想搭建一个可以自主管理的博客，然后去网上搜了一下后，发现GitHub pages就提供这样一种功能，能普通用户免费在上面进行搭站，于是就根据官方文档和各种网上资料进行自己搭站尝试。此间过程有些曲折，所以也把过程记录下来，提供给其他的朋友进行参考。 基础知识 要使用jekyll+github pages搭站，需要学些一个基础的知识，这样才能在使用的过程中得心应手。关于jekyll的用法，如果有不熟悉的，可以参考博主的另一篇文章jekyll基本概念介绍和安装 如果看到这里的，博主就假设已经知道jekyll是个什么东西，以及会markdown等语言了。那么接下来就给大家介绍怎么利用github pages来搭建自己的博客站。 搭建步骤 第一步：物色自己喜欢的模板 github pages本身提供了一些简单的模板可以在setting中进行配置，不过可选择的太少，所以如果没有喜欢的可以去其它地方多挑几个找到自己喜欢的模板。博主在进行搜索过程中，无意找到了一位大神的blogJekyll&amp;Github Pages博客模板挑选和配置，然后里面介绍了几个找模板的地方，这里接只接做一个搬运工，将这几个地址copy过来了   jekyllthemes.org  jekythemes.net  mademistakes (最后博主我也是在这个大神的几个模板中挑中了现在这个模板)第二步：github创建blog项目 按照官方文档github pages新建一个github pages项目，并以username.github.io格式命名新分支。 第三步：导入模板 导入模板有两种方式：一种是本地自己直接clone模板项目的github文件，然后放到自己项目中进行编译，还有一种是通过远程的方式，自己的项目中没有模板项目的任何文件。这两种的区别是，远程的每次build的时候需要通过去远端拉取相关资源，如果本地调试的时候，网路不好可能会导致项目启动很慢。但博主作为一个洁癖，为了使自己的项目看起来干净，所以选择了第二种方式。如果使用第二种远端的方式，那么只需要在项目的根目录下创建一个_config.yml的文件，并将主题配置写进文件就可以了，还是以博主自己为例： 然后在_config.yml文件中写入remote-theme配置信息 remote_theme           : \"mmistakes/minimal-mistakes\"第四步：导入博客 如果已经有博客了，那么就将博客直接导入到_posts目录下，并按照模板以及jekyll的配置规则，进行配置就好了。 第五步：本地调试并推送到github中 到了这一步，那么恭喜你，你离成功就只差一步之遥了。在本地调试，布局等都符合预期后，就可以直接将项目push到github中了，然后等待github page帮你构建项目，并启动就好了。 第六步：欣赏自己的博客站 在github的项目setting页面，在github pages配置中，就可以看到自己的博客站域名，点击后就可以看到属于自己的博客了👏 ","categories": ["jekyll"],
        "tags": [],
        "url": "http://localhost:4000/jekyll/%E5%88%A9%E7%94%A8jekyll+github-pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/",
        "teaser":null}]
